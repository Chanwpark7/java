package com.clsex;

//이 클래스는 개, 고양이, 오리의 부모 클래스로 정의될 예정.
//원래는 부모 클래스를 먼저 정의하고 자식을 확장(extends) 해야 하는데, 강의 흐름상 거꾸로 함.
/*
 * 상송(Inheritance) : 객체 지향에서 상속은 매우 중요.
 * 상속은 기본적으로 부모가 가진 모든것을 자식이 내려받는 형태. 하지만 내려받는 것중 안되는것이 있는데,
 * 1. 생성자는 상속이 되지 않음.
 * 2. private 으로 선언된 것 또한 상속되지 않음.(정확히는 접근 불가)
 * 
 * 이외에는 모두 상속을 받음.
 * 
 * 상속이라는 개념은 실제적으로 확장이라는 개념으로 생각해야 편함.
 * 부모가 가진 속성과 메소드 외에 나중에 추가될 속성과 메소드가 있다면 기존 클래스를 뜯어 고치는게 아니라, 연관성이 분명 하다면
 * 상속을 통해 자식이 그 확장 개념을 정의 한다라고 생각하면 편함.
 * 
 * 이렇게 상속을 통해 클래스를 확장할 수 있는데, 하나의 부모는 하나 이상의 자식 클래스를 둘 수 있지만, 자식은 반드시 하나의 부모 클래스만
 * 상속 받을 수 있음.
 * 
 * 상속은 자식이 부모를 상속하겠다는 키워드로 선언하는데, extends 를 사용함.
 * 
 * 추상화(Abstraction) : 추상화란 개념은 특정 클래스의 메소드가 자신을 위한 것이 아닌 상속이 주 목적인 클래스에 대해 적용되는 설계기법이다.
 * 예를 들어, 클래스를 정의하는 목적이 자신의 인스턴스(객체)를 생성해서 메소드등을 이용하는게 아닌, 상속이 주 목적인 경우엔
 * 자신의 클래스는 추상 클래스로 선언하고 자식이 자신의 클래스를 상속 받아 추상 메소드를 반드시 오버라이드 하도록 하는데 있다.
 * 추상 클래스는 문법적으로 위 설명의 목적에 따라 메소드의 기능만 상속 하는데에 초점이 있기 때문에 메소드를 정의하지 않는다.
 * 따라서 메소드의 body 가 없이 선언부만 갖게 된다. 이렇게 선언부만 갖게 되는 메소드는 추상 메소드라고 선언을 해줘야 하는데
 * 이때 사용되는 키워드가 abstract 이다.
 * 
 * 이렇게 추상 메소드를 하나이상 보유한 클래스는 반드시 추상 클래스로 선언이 되어야 하며(안그럼 에러 뜸), 이를 상속 받은 자식 클래스는
 * 반드시 추상 메소드를 오버라이드 하거나, 하지 않을시엔, 자신도 추상 클래스로 선언되어야 한다.
 * 
 * 이렇게 추상화를 하는 주 목적은, 상속되어진 메소드를 반드시 오버라이드 하도록 강제화 하는데 있다.
 * 
 * 이런 추상 메소드를 보유한 추상 클래스는 자신의 인스턴스를 생성할 수 없고(자신의 객체를 생성할 수 없고) super type 으로만 존재할 수 있다.
 * 
 * 이런 추상화 개념은 객체지향의 중요한 개념인 다형성을 수행하는데에 있다.
 */
public abstract class Animal {
	
	public String aType;//상속받은 객체가 어떤 타입(Dog, Cat, Duck) 인지를 초기화 하는 필드 선언
	
	//만약 부모가 생성자를 하나 이상 정의 하면, 기본 생성자가 사라지기 때문에 자식은 명시적으로 부모의 생성자 중 하나를 호출 해야함.
	public Animal(String aType) {
		this.aType=aType;
	}
	
	//어떤 동물인지를 String 으로 리턴하는 메소드 정의.
	@Override
	public String toString() {
		return super.toString()+" 이것은 " + aType;
	}
//	public String toString() {
//		return "이것은 " + aType;
//	}
	
	//내용부는 자식이 필요없는 부분이기 때문에 설계적인 목적으로는 추상화의 대상이 됨.
	public abstract void sound();
}
